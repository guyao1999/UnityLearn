### 学习笔记

[TOC]

#### Protobuff学习

参考链接：https://developers.google.com/protocol-buffers/docs/pythontutorial

​       使用protobuff，你只需要写一个.proto文件来定义的数据结构，然后 protocol buff的编译器就会自动实现一个类来编码和解析你定义的数据结构。这个类提供了setter函数和getter函数可以让你直接获得protocol buffer中的数据。更重要的是，protocol buffer支持格式的扩展，方便你新的解码方式来解码使用旧编码的数据。

##### 定义你的Protocol 格式

```protobuf
syntax = "proto2";

package tutorial;  //包的声明 

message Person {  //消息的定义
  optional string name = 1;  //
  optional int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    optional string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;  //可以存多个电话  动态数组
}

message AddressBook { 
  repeated Person people = 1;  //表示这个电话簿中有很多个人
}

```

1. 后面的1 2 3是一个唯一的tag,用于标识这个元素，方便二进制的编码。1-15号在编码时比更高的编号少需要一个byte的数据，所以，最佳的选择是，结构体中常用的到元素放在1-15号的位置上，16号位置以上放置不常用的元素。

2. 重复字段中的每个元素都需要对tag再进行一次编码，因此将重复字段放在前1-15号位置最为理想

3. 每个定义的元素都必须使用以下几个关键字来定义：

   **optional:**  这个字段可以不进行设置，不是必须的。如果这个字段没有指定值，就是否默认的值，例如上面我们设置`PthoneType`的默认类型为HOME.如果自己没有指定默认值，那么就使用系统的默认值。数字类型0为默认值;字符串类型，空为默认类型;布尔类型，false为默认值；对于嵌套的消息类型，默认值为“默认实例”或者消息定义时的“原型”。当调用访问器来访问一个没有赋值的字段的值的时候，总是返回这个字段的默认值。

   **repeated:** 这个标识这个字段可以被重复很多次。字段的重复顺序将被保存在protocol buff中。我们可以将这个字段理解成一个动态数组。

   **required:** 这个标识这个字段必须设置，否则就认为这个消息没有被初始化，序列化一个为初始化的消息将会导致异常，解析一个未初始化的消息将会失败。（required这个字段使用时要谨慎，当一个字段你希望它有时没有时，你就不能使用required来进行定义，在Google内部，基本不用required这个字段来进行定义，并且proto3中已经不再支持required这个字段）

##### 编译你的Protocol Buffers

当你有一个.proto文件时，你接下来要做的就是生成能够读写AddressBook message的类，要达成这个目的，你需要运行protocol buffer的编译器protoc来编译你的.proto文件。

1、下载包https://developers.google.com/protocol-buffers/docs/downloads

> 首先下载protobuf文件
>
> 在src文件中添加protoc.exe文件（可以自己编译添加，最好的方法是下载编译好的文件复制到这个文件下）
>
> protobuf/python文件下运行一下几个命令
>
> > python setup.py build
> >
> > python setup.py test
> >
> > python setup.py install
>
> 将protoc添加到系统的环境变量中，如果protoc --version运行成功表示环境变量添加成功

2、现在，可以开始进行运行编译器来进行编码（需要指定源文件和目标文件），运行之后生成一个addressbook_pb2.py文件

```c
protoc -I=D:/chromeDownload/protobuf-2.5.0/examples --python_out=D:/chromeDownload/protobuf-2.5.0/examples D:/chromeDownload/protobuf-2.5.0/examples/addressbook.proto
```

##### Protocol Buffer API

和java以及c++的protocol buffer代码不一样，python的protocol buffer的编译器没有直接生成访问你定义的数据的代码，而是生成了一些message、enums、等字段的描述符，还有一些奇怪的类。

```python
class Person(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType

  class PhoneNumber(message.Message):
    __metaclass__ = reflection.GeneratedProtocolMessageType
    DESCRIPTOR = _PERSON_PHONENUMBER
  DESCRIPTOR = _PERSON

class AddressBook(message.Message):
  __metaclass__ = reflection.GeneratedProtocolMessageType
  DESCRIPTOR = _ADDRESSBOOK
```

这个类中重要的是`__metaclass__`这一行,本教程中不讲解python中元类是如何工作的，但是你可以将他们理解成一个用于创建类的模板。在加载时，GeneratedProtocolMessageType这个将使用指定的描述符来创建处理每个消息类型所需要的python方法，并把他们添加到相关的类中，然后你完全可以在代码中来使用这个类。

最后，你完全可以使用Person类，就好像他就是Message基类中定义的一个常量一样，例如：

```python
import addressbook_pb2
person = addressbook_pb2.Person()
person.id = 1234
person.name = "John Doe"
person.email = "jdoe@example.com"
phone = person.phones.add()
phone.number = "555-4321"
phone.type = addressbook_pb2.Person.HOME
```

注意，这种赋值方式并不是通过python对象来添加任意的字段，如果你给一个没有的字段进行赋值，就会导致AttributeError，如果你将一个错误的类型进行了赋值，就会导致TypeError。同样，在给字段赋值之前读取这个字段，得到的将是这个字段的默认值。

```python
person.no_such_field = 1  # raises AttributeError
person.id = "1234"        # raises TypeError
```

关于编译器生成的python的代码的详细信息，[查看手册](https://developers.google.com/protocol-buffers/docs/reference/python-generated)

**枚举**

枚举被python中的元类扩展成了一个带值的常量符号集，例如访问`addressbook_pb2.Person.PhoneType.WORK` 就能得到2这个值

**标准的消息方法**

一个message类通常以包括了一些其他的方法，这些方法使得你可以操作整个message

- `IsInitialized()`：检查是否所有的requied字段都进行了赋值
- `__str__()`:返回一个可阅读的messages,通常用于调试（通常通过`str(message)` 或`print message`来进行调用）
- `CopyFrom(other_msg)`:将其他message的值复制给当前的message
- `Clear()`:将message中所有字段清楚回到空的状态

Message实现的详细方法，[查阅Message的API文档](https://googleapis.dev/python/protobuf/latest/google/protobuf/message.html#google.protobuf.message.Message)

**解析和序列化**

最后，每个protocol buffer类都有用于从protocol buffer的二进制形式中进行读取和写某一字段的方法，包括以下方法：

- `SerializeToString()`:序列化这个message并且作为string类型进行返回。注意，这些字节现在是二进制的，二不是text文本，我们只是使用string类型来作为容器来进行表示。
- `ParseFromString(data)`:解析一段给定的字符串

**note**: protocol buffers和面向对象设置的protocol buffer类只是数据的持有者（如c中的结构体），他们并不提供额外的方法，在对象模型中，他们不是好公民。如果你想给生成的类添加丰富的行为，最好的方法是将生成protocol buffer类封装在一个特定的应用程序类中。如果你无法控制.proto文件的设置，将protocol buffer类进行封装也是一种好的思想。在这种情况下，你可以是一个包装类去创建一个更合适应用程序的特定环境的接口：隐藏一些数据和方法，将便捷的方法暴露出来。你永远不要通过继承他们来向生成的类添加新的行为，因为这将破坏内部的机制，并且也不是好的面向对象的编程实践。（总结：不要直接修改生成的类或者继承生成的类然后在上面添加新的方法。）

##### 向一个message中写数据

使用以下的代码，输入一个用户的信息，将其添加到了addressbook文件中

```python
#! /usr/bin/python

# See README.txt for information and build instructions.

import addressbook_pb2
import sys

# This function fills in a Person message based on user input.
def PromptForAddress(person):
  person.id = int(raw_input("Enter person ID number: "))
  person.name = raw_input("Enter name: ")

  email = raw_input("Enter email address (blank for none): ")
  if email != "":
    person.email = email

  while True:
    number = raw_input("Enter a phone number (or leave blank to finish): ")
    if number == "":
      break

    phone_number = person.phone.add()
    phone_number.number = number

    type = raw_input("Is this a mobile, home, or work phone? ")
    if type == "mobile":
      phone_number.type = addressbook_pb2.Person.MOBILE
    elif type == "home":
      phone_number.type = addressbook_pb2.Person.HOME
    elif type == "work":
      phone_number.type = addressbook_pb2.Person.WORK
    else:
      print "Unknown phone type; leaving as default value."

# Main procedure:  Reads the entire address book from a file,
#   adds one person based on user input, then writes it back out to the same
#   file.
if len(sys.argv) != 2:
  print "Usage:", sys.argv[0], "ADDRESS_BOOK_FILE"
  sys.exit(-1)

address_book = addressbook_pb2.AddressBook()

# Read the existing address book.
try:
  f = open(sys.argv[1], "rb")
  address_book.ParseFromString(f.read())
  f.close()
except IOError:
  print sys.argv[1] + ": File not found.  Creating a new file."

# Add an address.
PromptForAddress(address_book.person.add())

# Write the new address book back to disk.
f = open(sys.argv[1], "wb")
f.write(address_book.SerializeToString())
f.close()

```

##### 向一个message中读取信息

```python
#! /usr/bin/python

# See README.txt for information and build instructions.

import addressbook_pb2
import sys

# Iterates though all people in the AddressBook and prints info about them.
def ListPeople(address_book):
  for person in address_book.person:
    print "Person ID:", person.id
    print "  Name:", person.name
    if person.HasField('email'):
      print "  E-mail address:", person.email

    for phone_number in person.phone:
      if phone_number.type == addressbook_pb2.Person.MOBILE:
        print "  Mobile phone #:",
      elif phone_number.type == addressbook_pb2.Person.HOME:
        print "  Home phone #:",
      elif phone_number.type == addressbook_pb2.Person.WORK:
        print "  Work phone #:",
      print phone_number.number

# Main procedure:  Reads the entire address book from a file and prints all
#   the information inside.
if len(sys.argv) != 2:
  print "Usage:", sys.argv[0], "ADDRESS_BOOK_FILE"
  sys.exit(-1)

address_book = addressbook_pb2.AddressBook()

# Read the existing address book.
f = open(sys.argv[1], "rb")
address_book.ParseFromString(f.read())  #convert binary to  string
f.close()

ListPeople(address_book)

```

##### 扩展一个protocol buffer

如果你想你的新的buffer向后兼容，你之前的buffer向前兼容，你需要遵守以下这些规则

- 对于已经存在的字段的tag的编号，不要进行修改
- 不要添加或删除任何使用required定义的字段
- 可以删除optional或者repeated的字段
- 可以添加optional或者repeated的字段,但是，必须使用新的tag编号，并且这个编号之前没有被使用过，即使已经删除的字段使用过也不可以。

只要遵从了以上几点，旧代码就会很好的阅读到新的messgae,并且抛弃新增加的字段。对于旧代码，optional修饰的字段如果被删除了，将会使用默认的值，删除的repeated字段就是使用空值来代替。同样，记住，新的optional字段不会出现在旧的message中，所以你需要明确的检查这个字段是否使用了has_来设置，或者在.proto文件中指定了一个合理的默认值。如果这个默认值为没有指定，那么会根据字段的类型进行指定。同样记住，如果添加了一个repeated的字段，你的新代码将无法判断这个字段是否为空，因为他没有has\_标签.

##### 扩展应用

protocol buffers提高了超过了简单的访问和序列化的方法。

其中一个新的特性就是反射。你可以迭代message的字段和操作其中的值，而不用对每一种类型写特定的访问函数。其中反射一个很有用的点在于，将protocol message转换为其他的编码方式，例如xml或者json格式。反射的一种更高级的用法是用于查找两条message之间的不同，或者开发一种“protocol message专用的正则表达式规则”以实现对message中具体内容的匹配。如果你的想象力丰富，你可以将protocol buffers实现成比最初的续期还要广的范围。 

关于反射方面，请[参考文档](https://googleapis.dev/python/protobuf/latest/google/protobuf/message.html#google.protobuf.message.Message)

#### protobuf在lua中的使用

[参考链接](https://blog.csdn.net/qq_29473881/article/details/107958275)

1. 首先protobuff没有lua版本，google官方没有提供将.proto文件转换为lua文件的方式，但是网易的开发人员实现了这个方法。项目名称为proto-gen-lua

2. 环境搭建步骤

   > 安装python27运行环境、
   >
   > 下载protoc-gen-lua源码
   >
   > 下载protobuf源码，需要使用它来提供模板

3. 编译步骤

   > 下载protocbuff源码，在python目录下运行以下三个方法生成对应的文件夹
   >
   > - python setup.py build
   >
   > - python setup.py test
   >
   > - python setup.py install
   >
   > 下载protoc-gen-lua源码，在src文件夹中添加protoc.exe文件
   >
   > 在protoc-gen-lua文件夹下编写buildproto.bat脚本，脚本内容如下(该脚本将自动寻找所有的.proto文件，将其编译成.lua文件)
   >
   > ```bat
   > rem 
   > cd D:\chromeDownload\protoc-gen-lua\luascript  #切换到对应的文件夹
   > rem 
   > for %%i in (*.proto) do (    #找到所有的.proto文件
   > echo %%i  
   > "D:\chromeDownload\protoc-gen-lua\protoc.exe" --plugin=protoc-gen-lua="D:\chromeDownload\protoc-gen-lua\plugin\protoc-gen-lua.bat" --lua_out=. %%i  
   >   
   > )  
   > echo end  
   > pause
   > #protoc.exe为protobuf的编译之后的可执行文件
   > #protoc-gen-lua.bat的作用为运行protoc-gen-lua.py文件
   > 
   > #proto [protoc-gen-lua] --lua_out=./foo.proto  官方的运行方式
   > ```
   >
   > 编写proto-gen-lua.bat脚本，脚本内容如下 （运行protoc-gen-lua.py文件）
   >
   > ```bat
   > @python D:\chromeDownload\protoc-gen-lua\plugin\protoc-gen-lua
   > ```

4. 运行编译之后的proto文件

   > 运行时会出现requir pb不存在的错误，这是因为现在的pb文件时一个pb.c文件，我们需要运行makefile将pb.c转换为pb.os。所以我们需要在我们的电脑上安装make环境。
   >
   > 当make环境安装号之后，可以通过test.lua文件来测试.proto文件在lua中的使用

#### DGTween

[参考链接](https://blog.csdn.net/qq_42672770/article/details/106378946)

https://blog.51cto.com/u_15185317/3699911

#### AssetBundle学习



#### DOTween学习

#### Spine学习

#### python学习
